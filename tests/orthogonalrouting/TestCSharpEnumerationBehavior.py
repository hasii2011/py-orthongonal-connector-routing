
from typing import List
from typing import NewType

from unittest import TestSuite
from unittest import main as unitTestMain

from codeallybasic.UnitTestBase import UnitTestBase

from orthogonalrouting.enumerations.ConnectorOrientation import ConnectorOrientation
from orthogonalrouting.models.Point import Point
from orthogonalrouting.models.Point import Points
from orthogonalrouting.models.Point import pointsFactory

StringList = NewType('StringList', List[str])

firstList: StringList = StringList(
    [
        'HASII', 'FKS', 'Ozzee'
    ]
)
secondList: StringList = StringList(
    [
        'HASII', 'FKS', 'Ozzee', 'Stranger', 'Tyler', 'Pat'
    ]
)


class TestCSharpEnumerationBehavior(UnitTestBase):
    """
    Auto generated by the one and only:
        Gato Malo â€“ Humberto A. Sanchez II
        Generated: 23 March 2024

    A set of code to figure out how to emulate some C# Enumerable behavior
    https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except?view=net-8.0
    https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault?view=net-8.0
    """

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

    def setUp(self):
        super().setUp()

    def tearDown(self):
        super().tearDown()

    def testOrderByThenBy(self):

        points: Points = pointsFactory()
        points.append(Point(50, 1))
        points.append(Point(50, 2))
        points.append(Point(30, 6))
        points.append(Point(60, 5))
        points.append(Point(60, 4))
        points.append(Point(90, 2))

        self.logger.info(f'Presorted x: {points}')
        # This isa 2 key sort with a lambda
        points.sort(key=lambda point: (point.x, point.y))

        self.logger.info(f'Sorted x: {points}')
        self.assertEqual(Point(50, 1), points[1])
        self.assertEqual(Point(50, 2), points[2])
        self.assertEqual(Point(60, 4), points[3])
        self.assertEqual(Point(60, 5), points[4])

    def testExcept(self):

        unique: StringList = self._difference(first=firstList, second=secondList)

        self.assertTrue('Tyler'  in unique, 'wth')
        self.assertTrue('Pat'    in unique, 'wth')
        self.assertFalse('HASII' in unique, 'wth')

    def testFirstOrNoneGetFirst(self):

        unique: StringList = self._difference(first=firstList, second=secondList)

        first: str = self._firstOrNone(strList=unique)

        self.assertEqual('Stranger', first, 'Incorrect first one')

    def testUpdateListInMethod(self):

        testList: List[str] = ['hasii', 'fks']

        self._updateListInternally(stringList=testList)

        self.assertIn('ozzee', testList, 'Oops not updated')

    def testEnumByValue(self):

        leftEnumeration: ConnectorOrientation = ConnectorOrientation(0)

        self.assertEqual(ConnectorOrientation.LEFT, leftEnumeration, 'Wah, I was expecting left')

    def _difference(self, first: StringList, second: StringList) -> StringList:

        if len(first) >= len(second):
            return self._realDifference(longerList=first, shorterList=second)
        else:
            return self._realDifference(longerList=second, shorterList=first)

    def _realDifference(self, longerList: StringList, shorterList: StringList) -> StringList:

        differenceList: StringList = StringList([])

        for element in longerList:
            if element not in shorterList:
                differenceList.append(element)

        return differenceList

    def _firstOrNone(self, strList: StringList):
        if len(strList) == 0:
            return None
        else:
            return strList[0]

    def _updateListInternally(self, stringList: List[str]):

        stringList.append('ozzee')


def suite() -> TestSuite:
    import unittest

    testSuite: TestSuite = TestSuite()

    testSuite.addTest(unittest.defaultTestLoader.loadTestsFromTestCase(testCaseClass=TestCSharpEnumerationBehavior))

    return testSuite


if __name__ == '__main__':
    unitTestMain()
